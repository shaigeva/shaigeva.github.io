[{"content":"(this is the first post in a series about ai-native frameworks)\nLike many others, I spent a lot of time thinking about AI and software development.\nI belong to the camp that believes that AI is a total paradigm shift - it\u0026rsquo;ll redefine the ecosystem and what it means to create software, and it\u0026rsquo;ll be the deepest change we have seen to date.\nMy own \u0026ldquo;flavor\u0026rdquo; of thinking about this is to try, from an engineering perspective, to understand what that change would look like.\nFigure out what are the technical \u0026ldquo;bottlenecks\u0026rdquo; and what would move the needle on them.\nDo the LLMs have to be essentially smarter for this to happen? Do we need to create some specific tooling? Disallow use of some tooling? Maybe a specific workflow?\nI\u0026rsquo;ve come to the conclusion that the way forward goes through something I think of as AI-native frameworks**, and AI engines that use these frameworks to develop software.\nVery loosely, what I mean by a framework is \u0026ldquo;definitions that dictate important aspects of the code and workflow\u0026rdquo;.\nThis can include things like programming language, tooling, conventions.\nThe central point here is that we will not continue to write code like we do now. The specifications, design, coding practices, testing and workflows will change.\nAnd I think that change will be substantial.\nThe main reason I think this needs to happen is that any way I look at it, our current methods will simply make it very hard to implement some of the most important improvements that are coming.\nAnd since the productivity boosts are so significant - I believe it\u0026rsquo;ll happen.\nIn this series of posts, I will try to show in detail why I believe this and what kind of changes we can expect.\nI\u0026rsquo;ll start with some of the high-level of are some of the limitations of our current methods, and then dive into concrete, low-level examples: showing how something would be difficult for AI on general, and how we can make it substantially easier by enforcing specific solutions.\nI\u0026rsquo;ll try to set up POCs to show that things are realistic in places where it\u0026rsquo;s more difficult to see (I\u0026rsquo;m not planning actual implementation of a framework or engine).\nNOTE: MAYBE say something about how a standard way to approach difficult problems is both to find a direct solution, and to redesign the problem.\nThe approaches we\u0026rsquo;ll explore are all existing industry techniques, though I\u0026rsquo;m not aware of them being applied in an organized way to the general problem of programming with AI.\nWe\u0026rsquo;ll talk about design, tests, error handling, system architecture, random algorithms, functional programming, simulations, craaaaazy types, RAGs and a bunch of other cool stuff.\nSince I\u0026rsquo;ve had these ideas running around in my head for while and at least for me they are interesting, I felt like it\u0026rsquo;s time to share.\nI hope you find this interesting as well and that it\u0026rsquo;ll spark some discussion :)\nPing me on social and let me know!\n** There are other names we can call this except AI-native. I also have AI-driven and AI-first in mind. The term AI-native actually comes from Tessl. I like it so adopted it as the main way I think of it.\nNext post: Why AI frameworks? (high level)\n","permalink":"https://shaigeva.com/posts/ai_frameworks/01_ai_frameworks_intro/","summary":"\u003cp\u003e(this is the first post in a series about ai-native frameworks)\u003c/p\u003e\n\u003cp\u003eLike many others, I spent a lot of time thinking about AI and software development.\u003c/p\u003e\n\u003cp\u003eI belong to the camp that believes that AI is a total paradigm shift - it\u0026rsquo;ll redefine the ecosystem and what it means to\ncreate software, and it\u0026rsquo;ll be the deepest change we have seen to date.\u003c/p\u003e\n\u003cp\u003eMy own \u0026ldquo;flavor\u0026rdquo; of thinking about this is to try, from an \u003cstrong\u003eengineering\u003c/strong\u003e perspective, to understand what that change\nwould look like.\u003cbr\u003e\nFigure out what are the technical \u0026ldquo;bottlenecks\u0026rdquo; and what would move the needle on them.\u003cbr\u003e\nDo the LLMs have to be essentially smarter for this to happen? Do we need to create some specific tooling?\nDisallow use of some tooling? Maybe a specific workflow?\u003c/p\u003e","title":"AI-Native Development Frameworks (blog post series)"},{"content":"This is a series of posts, following a talk I gave (twice - at Pycon-US 2023 and Pycon-IL 2024), about testing best (and not-so-best) practices.\nThe talk shares 10 practices that I had bad experience with, along with ways of avoiding them.\nStarting with simple (but useful!), and moving on to more complex ideas:\nThere are no tests (warm up) Untested tests The tests are not isolated No locality of behavior Unclear language Testing too many things Improper test scope Test doubles everywhere Slow tests Wrong priorities Videos and slide decks from the talks\n10 Ways To Shoot Yourself In The Foot With Tests - PyCon-US 2023 (English) Given at Salt Lake City, Utah.\nSlides: Slideshare PyCon US 2023\n10 Ways To Shoot Yourself In The Foot With Tests - PyCon-IL 2024 (Hebrew) Slides: Slideshare PyCon IL 2024\n","permalink":"https://shaigeva.com/posts/10_footguns/ten_footguns/","summary":"\u003cp\u003eThis is a series of posts, following a talk I gave (twice - at Pycon-US 2023 and Pycon-IL 2024), about testing best (and not-so-best) practices.\u003c/p\u003e\n\u003cp\u003eThe talk shares 10 practices that I had bad experience with, along with ways of avoiding them.\u003c/p\u003e\n\u003cp\u003eStarting with simple (but useful!), and moving on to more complex ideas:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"/posts/10_footguns/01_there_are_no_tests/\"\u003eThere are no tests\u003c/a\u003e (warm up)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/posts/10_footguns/02_untested_tests/\"\u003eUntested tests\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/posts/10_footguns/03_the_tests_are_not_isolated/\"\u003eThe tests are not isolated\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/posts/10_footguns/04_no_locality_of_behavior/\"\u003eNo locality of behavior\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/posts/10_footguns/05_unclear_language/\"\u003eUnclear language\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/posts/10_footguns/06_testing_too_many_things/\"\u003eTesting too many things\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eImproper test scope\u003c/li\u003e\n\u003cli\u003eTest doubles everywhere\u003c/li\u003e\n\u003cli\u003eSlow tests\u003c/li\u003e\n\u003cli\u003eWrong priorities\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eVideos and slide decks from the talks\u003c/p\u003e","title":"10 Ways To Shoot Yourself In The Foot With Tests"},{"content":" (this mini-post is part of a series about good testing practices)\nJust like with product code, if we put too many things in the same place we get a mess.\nMy rule of thumb is to try hard to test a single fact about the behavior of the code. And it helps if I use these specific words mentally.\nSINGLE. FACT. About the BEHAVIOR.\nExample Let\u0026rsquo;s continue with our example from the previous post, and say we have a book store and we\u0026rsquo;re testing the edit book functionality.\nFor example, that\u0026rsquo;s a single fact about the behavior the code: test_user_can_edit_their_own_book And, this is not a single fact, it\u0026rsquo;s too general: test_edit_book How do they compare? Easy to understand? Single fact test: It\u0026rsquo;s clear what the test checks. It\u0026rsquo;s clear that it only checks that. General test: we\u0026rsquo;ll need to read and understand all the test code to know. Easy to debug? Single fact test: If it fails, it\u0026rsquo;s clear what functionality stopped working. And because it\u0026rsquo;s small, it\u0026rsquo;ll be easy to debug it. General test: if it fails, anything related to edit book might have failed. We\u0026rsquo;ll need to dig in. And it does a lot of things, so debugging might be a lot of work. Conclusion Try to have each test case will test a SINGLE FACT about the BEHAVIOR of the code.\nThis makes a huge difference and it\u0026rsquo;s worth it to invest a lot into this.\n\u0026lt;\u0026lt; previous post: Unclear Language | (coming soon) next post: Improper Test Scope \u0026gt;\u0026gt; ","permalink":"https://shaigeva.com/posts/10_footguns/06_testing_too_many_things/","summary":"\u003cstyle\u003e\n.code-example {\n  background-color: #2E2E33;\n  padding: 10px;\n  margin-bottom:10px;\n  border-radius: 5px;\n  font-family: monospace;\n  white-space: pre;\n  color: #d5d5d6;\n  font-size: .78em;\n  line-height: 1.5;\n}\n.highlight-red {\n  color: red;\n}\n.highlight-green {\n  color: green;\n}\n\u003c/style\u003e\n\n\u003cp\u003e(this mini-post is part of a \u003ca href=\"https://shaigeva.com/posts/10_footguns/ten_footguns/\"\u003eseries\u003c/a\u003e about good testing practices)\u003c/p\u003e\n\u003cp\u003eJust like with product code, if we put too many things in the same place we get a mess.\u003c/p\u003e\n\u003cp\u003eMy rule of thumb is to try hard to test a single fact about the behavior of the code.\nAnd it helps if I use these specific words mentally.\u003c/p\u003e","title":"Footgun #6 - Testing Too Many Things"},{"content":"(this post is part of a series about ai-native frameworks)\nIn this post I\u0026rsquo;ll focus here on the reason I think frameworks are the direction and what I think they will include, where following posts will dive deeper into the technical details.\nAt a very high level, the rationale is this:\nIt makes sense to \u0026ldquo;aim our code for the AI\u0026rdquo;, because it\u0026rsquo;ll be the new norm. With the current way we\u0026rsquo;re making software, it\u0026rsquo;s just not realistic to make a paradigm shift happen, because AI cannot have a feedback loop that\u0026rsquo;s good enough to change code at an acceptable speed and self-heal enough issues. Therefore, I believe the only way forward is to have frameworks that dictate some important aspects of the code and workflow, in order to give AI what it needs so it can do its job. Let\u0026rsquo;s dig in.\nAn industrial revolution Soon enough, the vast majority of code will be written by AI.\nSo in a sense, this is a large automation movement.\nThings human craftsmen currently make will be handed over en masse to the machine.\nGiven that, it makes sense to think about the common case for software creation, which will soon be the automated process.\nAnd as with other automations, the automation might involve a redesign.\nThe printing press is not a faster pen, and digital photography is not a \u0026ldquo;better film camera\u0026rdquo;.\nThey work differently, and create something a little different.\nAnd we should expect the same from automating software creation.\nA reality of imperfection There\u0026rsquo;s a fundamental truth about \u0026ldquo;making things\u0026rdquo;: it\u0026rsquo;s not going to be perfect.\nThe specification might not be clear, some implicit assumption might be incorrect, or even a simple mistake. Randomness will happen.\nWe are imperfect humans in imperfect teams, building imperfect products in an imperfect reality.\nAnd it is the same with AI. LLMs have limits, and they have randomness built in.\nSo when AI makes a change, sometimes it won\u0026rsquo;t be what we need.\nIt\u0026rsquo;s not going to be the same imperfections a human creates, but it\u0026rsquo;ll happen.\nThe almighty feedback loop The way to deal with this reality is to iterate. We all know this:\nWe plan - decide what to do next. Then we do the thing. We verify - get feedback (check if that thing is a step in the right direction). Then, given that new information from the feedback - we go back to the beginning.\nPlan Do Verify And again and again\u0026hellip;\nFor me, this feedback loop is the main mental model for thinking about software development processes.\nProduct might iterate on UX details, a complex project would be built in iterations.\nAnd so would an individual development task.\nYou write some code, then you test and fix and test again. Deploy to staging and test some more, fixing again if you find a new bug etc. etc.\nThis is an essential part of dealing with imperfection or randomness.\nIf things sometimes go wrong, we need to know to spot the error and fix it.\nIt\u0026rsquo;s always an auto-correcting feedback loop.\nAn important note on speed: the shorter a feedback loop is, the better. This matters A LOT. Any mistake can send you off in the wrong direction, so you want to get feedback as early as possible.\nA simple example would be to try to write code for 3 days without ever running it, and then trying to test the whole thing.\nThere\u0026rsquo;s no surprise there. It\u0026rsquo;s a random process with some chance of going wrong each step and auto-correction. The more iterations you can squeeze in at a given timeframe, the more chance you have at reaching the goal.\nAI and our feedback loops Although not always discussed this way, a lot ofwhat we\u0026rsquo;re doing now with AI tools is integrating them into our own feedback loop.\nAnd when you look at it from this angle, you can see that a lot of the techniques we use to improve the performance of human+ai are just optimizing some part of our feedback loop - adding steps in the process for detailed planning, breaking down to smaller tasks, making sure the correct context gets in so it\u0026rsquo;s easier for the AI to \u0026ldquo;do\u0026rdquo; etc.\nAI\u0026rsquo;s internal feedback loop today An observation I\u0026rsquo;m making here is that the AI has (or can have) its own feedback loop before it hands the latest change over to us.\nMy own experience, and I\u0026rsquo;m sure many others\u0026rsquo; as well, is that the best outcome I get is if I set up an AI assistant for a feedback loop like this:\nUnderstand what to do next Create something small Write a new test + Run all relevant tests. If something breaks - the next action would be to fix it. And I let this run automatically in a loop until either all tests are green, it gives up or it starts going crazy.\nThis is possible, for example with Cursor, for some time now. In fact, Cursor will try to self-heal what it can out of the box - stuff like lint errors.\nA note here: like with human feedback loops, speed matters. If every small change takes 15 minutes, then it\u0026rsquo;s slow enough that the human can\u0026rsquo;t manage it, and it\u0026rsquo;d often be better for the human to do it themselves.\nThis works extremely well. The AI having its own internal self-healing feedback loop, backed by the right tests to make me feel safe-enough that nothing breaks, is a different category of productivity.\nSome bugs still get through to me. I test, but it\u0026rsquo;s kind of \u0026ldquo;skipping to the end of the process\u0026rdquo; - I would also do the same tests if I wrote the code, and find similar bugs.\nWhen I can set it up, it\u0026rsquo;s just great. But\u0026hellip; for most of my work, I can\u0026rsquo;t.\nAI\u0026rsquo;s internal feedback loop tomorrow So when I distill the situation as far as I can, this is what remains.\nAI will statistically make mistakes at any given step it does. Large, standard codebases and systems are FAR too complex for these \u0026ldquo;imperfections\u0026rdquo; to be rare. We must allow the AI to self-correct using a feedback loop, to minimize these. Any coding the AI does and which doesn\u0026rsquo;t have a good feedback loop - a human will have to understand every small part of it and test it thoroughly.\nThis has a \u0026ldquo;glass ceiling\u0026rdquo; of diminishing returns since even when the AI becomes far better at coding than it is today, the changes will be so large that it\u0026rsquo;ll be that much more difficult for a human to reason about them and test them.\nTherefore: any coding that we want AI to do consistently, has to be backed by a strong feedback loop like this, where it has the capability to consistently move forward, and it\u0026rsquo;s rare-enough that it makes significant mistakes without us knowing.\nIt is also important that it\u0026rsquo;ll be very, very rare that unexpected and unrelated things break. If you add a button and a serious security issue appears - that\u0026rsquo;s not an AI workflow that backs a paradigm shift.\nSo the feedback loop is sort-of a \u0026ldquo;constant\u0026rdquo; in this \u0026ldquo;movement to AI\u0026rdquo;. A requirement that must be satistified.\nThere\u0026rsquo;s no model strong enough, no shiny agentic workflow that will work without it, no brilliant prompt, no RAG pipeline that will get just the right context.\nIf it\u0026rsquo;s too slow, if it can\u0026rsquo;t prevent nasty surprises and can\u0026rsquo;t auto-heal most issues before it hands us a result, there are only incremental improvements to be had. Large increments, but still - it\u0026rsquo;s limited.\nWhat are the limiting factors? So, what\u0026rsquo;s preventing such a feedback loop today?\nTwitter is full of tips and tricks on rule files and project documentation, workflows that break out planning into different steps (and also some tools for mananging plan execution, as composed of small steps).\nThese help \u0026ldquo;plan\u0026rdquo; and \u0026ldquo;do\u0026rdquo;, though far from enough.\nThe way I see it, we have two significant bottlenecks:\nFirst: understanding complex code well, incl. flow execution. I believe there are codebases where this works pretty well, but certainly not consistently enough.\nAnd second: the real limiting factor of the AI software movement - \u0026ldquo;verify\u0026rdquo;.\nThe tests.\nWell, mostly the tests - there are other verifications.\nFor example, automatically taking a one-time screenshot of a UI component \u0026ldquo;before and after\u0026rdquo; and comparing is very much a verification, though it\u0026rsquo;s not considered a \u0026ldquo;test\u0026rdquo; by common terminology. But I\u0026rsquo;ll usually include all verification in \u0026ldquo;tests\u0026rdquo; to be a little less verbose.\nThe tests I\u0026rsquo;m proficient with tests. I have given testing a lot of attention for two decades, I give talks about tests, I had successes and failures and I have an \u0026ldquo;arsenal\u0026rdquo; of effective techniques.\nBecause of that, I know it\u0026rsquo;s not realistic to add good tests to most code bases. At least, good tests that will be fast enough.\nCode is usually not testable if it\u0026rsquo;s not designed to be testable.\nSome common issues are\nLogical complexity, where some component does a lot of stuff and it\u0026rsquo;s difficult to isolate what you want to test in a way that\u0026rsquo;s both reliable and simple enough. Especially for complex flows that include multiple steps and many components with non-trivial state changes. Technical complexity, where it\u0026rsquo;s difficult to set up things. A simple example would be data samples for complex processes, but the more hairy issues involve things like like relying on some external thing for which it\u0026rsquo;s tricky to simulate failure modes. Side-effects, where the code interacts with the outside world in some way. Consider something like this: we have an arbitrary microservice architecture with 50 repos, where some services are written in typescript, some are written in python without type hints, and the team has even braved Rust on one of them. We mostly use Postgres with redis, but some workflows use s3. 5 3rd party APIs handle a few concerns like payments, opening support tickets or similar. We might not even have a trivial way to set up \u0026ldquo;new clean test\u0026rdquo; on a local machine. Now, the AI made a significant change to a shared python library that deals with the DB.\nWhen you call the typescript web service, which will then call 15 different services, how easy will it be for the us to trust that all read-only transactions stay read-only and that the latest change doesn\u0026rsquo;t accidentally override a value in some obscure sequence of events where Stripe returns 502 once every 3 weeks? We can\u0026rsquo;t run all the options. It might not even be possible to technically test all failure modes for all 3rd party services that we use. And would it not run for 30 years if we tried?\nAnd since we\u0026rsquo;re not testing it out, what will we do? Do you trust any model that tells you \u0026ldquo;I\u0026rsquo;ve seen all the context, there\u0026rsquo;s no sequence of events that triggers a dormant bug from 2 years ago and breaks this\u0026rdquo;?\nWe need to trust it, or this doesn\u0026rsquo;t work.\nNow, there are solutions, but they require specific design patterns and tooling.\nI\u0026rsquo;ll finish this point here, because this is already a very long post.\nIf what I wrote here has not convinced you - let\u0026rsquo;s mark this as a debt to be explained, and one of the planned posts in the series will take a deep-dive into this point.\nFor now, let\u0026rsquo;s assume that adding good, fast tests to an arbitrary code base is very hard.\nHard enough that to make the paradigm shift it\u0026rsquo;s easier to switch coding styles than it is to create tools that can deal with the old code style.\nSecurity I\u0026rsquo;d be remiss if I didn\u0026rsquo;t mention security.\nEven for something as simple as testing locally - the disk on our machine typically has a .env file with secrets.\nAutomatically running a unit test that was created automatically, on code that was created automatically might leak that.\nSo if we want to be able to just let the AI do its thing with minimal supervision, it might be a good idea to have some guardrails.\nFrameworks It therefore seems that the most make-sense way forward, is to build AI-compatibility into every part of software creation - design, coding, workflows, security etc.\nIf tests on a general codebase are hard, let\u0026rsquo;s have a design that guarantees our codebases can be tested.\nIf we need to avoid leaking information, we probably need to address that.\nIt\u0026rsquo;s difficult enough to solve these issues if we \u0026ldquo;own\u0026rdquo; the tech stack and design, and can freely run any part of the code that we want.\nIf we don\u0026rsquo;t, it just becomes exponentially more difficult.\nWe need to understand what AI needs, and give it that, instead of trying to have it \u0026ldquo;just work\u0026rdquo; on whatever arbitrary code base we happen to have.\nThis is what I think of as an AI-native framework.\nIt would take a certain use case (hopefully relatively broad) and design some of the of the aspects of the project to make them AI-compatible.\nI don\u0026rsquo;t know what would be the granularity of these frameworks\nMaybe it\u0026rsquo;ll be a single idea like testing at a certain layer in an http web server and you would compose a bunch of these together Maybe it\u0026rsquo;ll be \u0026ldquo;FastAPI + Postgres + React has at least these layers and tests that look like these\u0026rdquo; Maybe it\u0026rsquo;ll be much more generic than that. Maybe the only frameworks we see will be part of paid platforms that also contain the AI engines that use the frameworks. You could satisfy a lot of these requirements by having something like Wix and have custom-generated-code hook into different parts of the system. I don\u0026rsquo;t think this is where it\u0026rsquo;s going, but maybe. What I am sure of is that frameworks will set up software projects so that AI engines can have effective feedback loops.\nThey will include at least some strict design and testing guidelines, and will probably include ways to document and declare a spec for parts of the software.\nI do believe the successful ones will probably be technology-specific, at least to some degree.\nThere are things we can do with some technologies that we can\u0026rsquo;t do with others, and they matter.\nFor example, we don\u0026rsquo;t have static types in javascript (put aside jsdoc for a sec), but we do have them in typescript. This changes some tradeoffs of what\u0026rsquo;s easy for the AI to self-heal and what is not.\nI believe some of the conventions we see in these frameworks will be very similar to what some teams already do.\nBut some will not. It is easier for a machine to do some things that are difficult for us and vice versa.\nFor example, the way it makes sense for an AI to use types is typescript is not the same in my opinion as the common conventios. I\u0026rsquo;ll dig into this quite a bit later on.\nSome tooling will almost certainly be very different from today.\nI don\u0026rsquo;t think we\u0026rsquo;ll have Python code generation at scale without at least something like a sandbox be part of common frameworks. Maybe even the ability to easily configure file access, limitations on network calling etc.\nWrapping up I hope I managed to make the case that it\u0026rsquo;ll very difficult to have industrial-strength code generation at scale for arbitrary code bases.\nAnd that we must therefore explore frameworks that would allow us to control enough of the structure of the code that would allow the AI to have an effective internal feedback loop.\nIn the next post, we\u0026rsquo;ll start exploring an example of what a simple framework might look like.\n","permalink":"https://shaigeva.com/posts/ai_frameworks/02_why_ai_frameworks/","summary":"\u003cp\u003e(this post is part of a \u003ca href=\"https://shaigeva.com/posts/ai_frameworks/01_ai_frameworks_intro/\"\u003eseries\u003c/a\u003e about ai-native frameworks)\u003c/p\u003e\n\u003cp\u003eIn this post I\u0026rsquo;ll focus here on the reason I think frameworks are the direction and what I think they will include,\nwhere following posts will dive deeper into the technical details.\u003c/p\u003e\n\u003cp\u003eAt a very high level, the rationale is this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIt makes sense to \u0026ldquo;aim our code for the AI\u0026rdquo;, because it\u0026rsquo;ll be the new norm.\u003c/li\u003e\n\u003cli\u003eWith the current way we\u0026rsquo;re making software, it\u0026rsquo;s just not realistic to make a paradigm shift happen, because AI\ncannot have a feedback loop that\u0026rsquo;s good enough to change code at an acceptable speed and self-heal enough issues.\u003c/li\u003e\n\u003cli\u003eTherefore, I believe the only way forward is to have frameworks that dictate some important aspects of the code and\nworkflow, in order to give AI what it needs so it can do its job.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLet\u0026rsquo;s dig in.\u003c/p\u003e","title":"Why AI frameworks?"},{"content":" (this mini-post is part of a series about good testing practices)\nAnother problem that makes it more difficult to understand tests is unclear language.\nTwo guidelines that help me deal with this:\nWe want to use decisive language We want the language to be specific and explicit Suppose we have a book store and we\u0026rsquo;re testing the functionality for editing a book.\nLet\u0026rsquo;s see some examples of test phrasing:\ndef test_edit_book(): ... This is simply too general.\nThere are so many things that might be tested, and this means almost nothing about what will get tested in practice.\ndef test_edit_book_works_correctly(): ... Adding things like \u0026ldquo;it works\u0026rdquo; or \u0026ldquo;it\u0026rsquo;s correct\u0026rdquo; - most of the time, this is just bloat.\nIt only makes the name bigger, but doesn\u0026rsquo;t give us any extra information.\ndef test_user_should_be_able_to_edit_their_own_book(): ... That\u0026rsquo;s much better - it\u0026rsquo;s a lot more specific.\nThe only problem here is the indecisive language.\nWhy \u0026ldquo;should\u0026rdquo;?\nWill this ever NOT be correct?\nIt\u0026rsquo;s both bloated and confusing.\nSo this as well - not optimal.\ndef test_user_can_edit_their_own_book(): ... That\u0026rsquo;s much better in my opinion.\nIt\u0026rsquo;s decisive, explicit and specific.\nI suggest to aim towards this whenever possible.\nConclusion When phrasing test names and descriptions, try to aim for decisive, specific and explicit language.\n\u0026lt;\u0026lt; previous post: No Locality of Behavior | next post: Testing Too Many Things \u0026gt;\u0026gt; ","permalink":"https://shaigeva.com/posts/10_footguns/05_unclear_language/","summary":"\u003cstyle\u003e\n.code-example {\n  background-color: #2E2E33;\n  padding: 10px;\n  margin-bottom:10px;\n  border-radius: 5px;\n  font-family: monospace;\n  white-space: pre;\n  color: #d5d5d6;\n  font-size: .78em;\n  line-height: 1.5;\n}\n.highlight-red {\n  color: red;\n}\n.highlight-green {\n  color: green;\n}\n\u003c/style\u003e\n\n\u003cp\u003e(this mini-post is part of a \u003ca href=\"https://shaigeva.com/posts/10_footguns/ten_footguns/\"\u003eseries\u003c/a\u003e about good testing practices)\u003c/p\u003e\n\u003cp\u003eAnother problem that makes it more difficult to understand tests is unclear language.\u003c/p\u003e\n\u003cp\u003eTwo guidelines that help me deal with this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWe want to use decisive language\u003c/li\u003e\n\u003cli\u003eWe want the language to be specific and explicit\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSuppose we have a book store and we\u0026rsquo;re testing the functionality for editing a book.\u003cbr\u003e\nLet\u0026rsquo;s see some examples of test phrasing:\u003c/p\u003e","title":"Footgun #5 - Unclear Language"},{"content":"(this mini-post is part of a series about good testing practices)\nOne testing problem that doesn\u0026rsquo;t get enough attention in my opinion is tests that don\u0026rsquo;t have locality of behavior.\nBy that I mean cases where a test is broken down into different parts in a way that makes understanding more difficult.\nThis is important in every type of code, and tests are no exception.\nExample: non-local data Consider this test:\ndef test_something(): data = Path(PATH_TO_DATA_FILE).read_text() assert calc_something(data) == 4.5 The data that the test uses is in a different file, so in order to understand the test we will need to locate that file and open it.\nEven if the data was in the same file, but a different place - it would still be an issue.\nNow, sometimes we don\u0026rsquo;t have a choice, and it\u0026rsquo;s the only way to do it.\nBut sometimes we do.\nFor example, if we can find a data example that\u0026rsquo;s small enough, we can do something like this:\ndef test_something(): data = “”” { \u0026lt;JSON data\u0026gt; } “”” assert calc_something(data) == 4.5 This is exactly the same test, but the data is local so it\u0026rsquo;s going to be much easier to understand at a glance, without \u0026ldquo;breaking the flow\u0026rdquo;.\nIt\u0026rsquo;s easier in tests than in production code One of the main problems with achieving locality of behavior is that it conflicts with DRY (\u0026ldquo;don\u0026rsquo;t repeat yourself\u0026rdquo;).\nWhat\u0026rsquo;s the problem with code duplication in production code?\nYou\u0026rsquo;ll often hear people talking about the \u0026ldquo;economics\u0026rdquo; - if you repeat a piece of code 3 times, then if you need to change that logic, you would need to do that work 3 times.\nHowever, this is actually a secondary consideration, especially if the number of repetitions is not high (let\u0026rsquo;s say 5 or less).\nThe real issue with repeating yourself is that duplication is an implicit dependency.\nIf you repeat the same logic in 3 different places, there\u0026rsquo;s a risk that if the logic needs to change, you would not notice one of these places, which would cause that \u0026ldquo;usage\u0026rdquo; to be deprecated and incosistent with the rest of the code - which will result in bugs and maintainability overhead, of course.\nThe nice thing about tests here is that this consideration is weaker, because of several factors.\nWhen we change code that has a test and make it behave differently, the relevant tests will usually break, so we will have something that points out to the duplicated \u0026ldquo;usages\u0026rdquo;. Where in production code - we only get that benefit if that piece of code has relevant tests - which might be very far from \u0026ldquo;always\u0026rdquo;. If the tests are focused and verify only a single fact, the number of times that we have duplication will be lower. And it\u0026rsquo;s far easier to write a test (at least a test that\u0026rsquo;s not end-to-end) that \u0026ldquo;checks one thing\u0026rdquo; than it is to write code that \u0026ldquo;does a single thing\u0026rdquo;, because if a piece of code does multiple things - you can just write multiple tests that run it separately, and each of them would test one thing. And, finally, if the mistake does happen in test-code and we forget to update a \u0026ldquo;usage\u0026rdquo; - it\u0026rsquo;ll render the test \u0026ldquo;wrong\u0026rdquo;, but it won\u0026rsquo;t actually cause a bug. Making a test wrong is bad, but it\u0026rsquo;s not as bad as a production bug, unless it affects a lot of tests. Of course, duplication is still something to consider - if there\u0026rsquo;s complex setup, or something that\u0026rsquo;s not complex but repeats many times - it\u0026rsquo;s probably worth it to extract functionality.\nThe point is that in production code, the right time to extract functionality is often after two or three usages - but in tests the balance allows for more.\nConclusion Be aware that tests which are \u0026ldquo;non-local\u0026rdquo; are far more difficult to maintain, and make a conscious effort to find ways to reduce the problem.\n\u0026lt;\u0026lt; previous post: The Tests Are Not Isolated | next post: Unclear Language \u0026gt;\u0026gt; ","permalink":"https://shaigeva.com/posts/10_footguns/04_no_locality_of_behavior/","summary":"\u003cp\u003e(this mini-post is part of a \u003ca href=\"https://shaigeva.com/posts/10_footguns/ten_footguns/\"\u003eseries\u003c/a\u003e about good testing practices)\u003c/p\u003e\n\u003cp\u003eOne testing problem that doesn\u0026rsquo;t get enough attention in my opinion is tests that don\u0026rsquo;t have locality of behavior.\u003c/p\u003e\n\u003cp\u003eBy that I mean cases where a test is broken down into different parts in a way that makes understanding more difficult.\u003c/p\u003e\n\u003cp\u003eThis is important in every type of code, and tests are no exception.\u003c/p\u003e\n\u003ch2 id=\"example-non-local-data\"\u003eExample: non-local data\u003c/h2\u003e\n\u003cp\u003eConsider this test:\u003c/p\u003e","title":"Footgun #4 - No Locality of Behavior"},{"content":"(this post is part of a series about good testing practices)\nWriting tests that are not isolated is a sure way to create unnecessary work for ourselves.\nBy \u0026ldquo;tests that are not isolated\u0026rdquo;, I mean tests that sometimes have a different outcome (failing / passing) if we run only a subset of them, if we run them in a different order or if we run them in parallel.\nWhy is this a problem? Let\u0026rsquo;s say we have 30 tests, and test 24 passes if we run it individually but fails if we run the entire test suite.\nIf the test was isolated, then there are only a limited number of things that can go wrong. The things that the test actually executes will almost certainly be the cause of the failure.\nBut now, of course, the reason for failure is not what test 24 checks, and not what any of the other tests checks either. The failure is caused by an implicit interaction between test 24 and, say, test 8.\nThis is difficult to debug, of course, because we would first need to play detective and find that it\u0026rsquo;s test 8 that\u0026rsquo;s causing the problem (which might take a LOT of effort, especially if the tests are e2e tests that run slowly or only in CI), and then track the combined flow of the tests to find the problematic interaction.\nBut it\u0026rsquo;s worse than this - what often happens is that we run the entire test suite, either locally or in CI, and test 24 fails - so we start analyzing it as if test 24 fails individually. We don\u0026rsquo;t even consider that it\u0026rsquo;s a combined failure, and sometimes we waste hours chasing irrelevant clues, just to get to the point that we notice the test passes if its executed separately.\nSo the fact that we have \u0026ldquo;individual tests\u0026rdquo; is actually a misleading illusion that only distracts us from the unfortunate truth - we have one gigantic test with inter-connected sub-sections.\nIf e2e tests run in parallel and sometimes run in different order, which makes this cross-test-failure flaky, we get the perfect storm and we might spend days of work on this.\nAnd, lastly, the situation could actually be worse - it might be that test 24 SHOULD fail, but it passes because of test 8, hiding a bug.\nWhat are the causes behind this? There are rare cases like technical limitations (e.g. external service rate limits), but in the vast majority of cases - it\u0026rsquo;s shared mutable state.\nA typical scenario for unit tests would be a global in-memory object, and for end-to-end tests maybe a row in a database.\nTest 8 would change that shared thing, and test 24 would therefore have a different state when it starts to execute, leading to the failure.\nSharing a resource that\u0026rsquo;s immutable (or never changes in practice) is not a problem - if it never changes, then it\u0026rsquo;s the same whether or not it\u0026rsquo;s accessed by multiple \u0026ldquo;consumers\u0026rdquo;.\nI\u0026rsquo;ve also seen more subtle cases of shared mutable state, for example tests that would rely on an email being sent through an actual email-sending service, and multiple tests checked for the same email.\nWhat can we do? First of all, because in my experience this is so often a very painful problem - I suggest to avoid this from the start, even if it means extra work or delaying writing some tests if can\u0026rsquo;t make them isolated at the moment.\nDO NOT create a suite of non-isolated e2e tests that use long-living mutating database entities. This is very very likely to cause a crisis down the road.\nBecause the problem is usually shared mutable state, we mostly just need to avoid that specific issue.\nUnit tests can use the same in-memory objects, but they have to be immutable, or at least never changed by convention.\nIf this is not an option - either create the object in every test or have some original which you clone at the beginning of the tests.\nThe trickier part are higher-level tests that use expensive resources like a database, where full initializations might cause the tests to be too slow.\nIf it\u0026rsquo;s not too expensive - initialize the entire thing, of course.\nOtherwise - make sure to clean up - delete created resources and revert the database / file system / etc. to its original state before continuing.\n\u0026lt;\u0026lt; previous post: Untested Tests | next post: No Locality of Behavior \u0026gt;\u0026gt; ","permalink":"https://shaigeva.com/posts/10_footguns/03_the_tests_are_not_isolated/","summary":"\u003cp\u003e(this post is part of a \u003ca href=\"https://shaigeva.com/posts/10_footguns/ten_footguns/\"\u003eseries\u003c/a\u003e about good testing practices)\u003c/p\u003e\n\u003cp\u003eWriting tests that are not isolated is a sure way to create unnecessary work for ourselves.\u003c/p\u003e\n\u003cp\u003eBy \u0026ldquo;tests that are not isolated\u0026rdquo;, I mean tests that sometimes have a different outcome (failing / passing) if we run\nonly a subset of them, if we run them in a different order or if we run them in parallel.\u003c/p\u003e\n\u003ch2 id=\"why-is-this-a-problem\"\u003eWhy is this a problem?\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s say we have 30 tests, and test 24 passes if we run it individually but fails if we run the entire test suite.\u003c/p\u003e","title":"Footgun #3 - The Tests Are Not Isolated"},{"content":"(this post is part of a series about good testing practices)\nSometimes our tests lie to us.\nWe have a test that was supposed to protect us from some bug, but that bug happened after all.\nOf course, what happened was that we made a mistake, and the test didn\u0026rsquo;t really verify what we thought it does.\nAs it turns out - when we write a test, it\u0026rsquo;s a good idea to spend a little effort to verify the test actually works.\nTo make sure that if the bug happens, the test does indeed fail.\nHow to avoid this My suggestion -\nWhen you write a test, for every assertion you write, make a small change:\nEither change the code a little and introduce the bug. Or change the test a little bit, so it verifies something a little different. This way you will be able to see if the test would have failed in the way you expect it to, and you\u0026rsquo;ll be able to count on it.\n\u0026lt;\u0026lt; previous post: There Are No Tests | next post: The Tests Are Not Isolated \u0026gt;\u0026gt; ","permalink":"https://shaigeva.com/posts/10_footguns/02_untested_tests/","summary":"\u003cp\u003e(this post is part of a \u003ca href=\"https://shaigeva.com/posts/10_footguns/ten_footguns/\"\u003eseries\u003c/a\u003e about good testing practices)\u003c/p\u003e\n\u003cp\u003eSometimes our tests lie to us.\u003c/p\u003e\n\u003cp\u003eWe have a test that was supposed to protect us from some bug, but that bug happened after all.\u003c/p\u003e\n\u003cp\u003eOf course, what happened was that we made a mistake, and the test didn\u0026rsquo;t really verify what we thought it does.\u003c/p\u003e\n\u003cp\u003eAs it turns out - when we write a test, it\u0026rsquo;s a good idea to spend a little effort to verify the test actually works.\u003cbr\u003e\nTo make sure that if the bug happens, the test does indeed fail.\u003c/p\u003e","title":"Footgun #2 - Untested Tests"},{"content":" My name is Shai Geva.\nI\u0026rsquo;ve been creating software for humans, with humans, for over 20 years.\nI\u0026rsquo;m mostly a builder, but have also played more \u0026ldquo;high level roles\u0026rdquo;, like product and management (my current position is tech-lead at Sayata).\nI write about various topics, focusing on code quality and automated tests, which are a great passion for me.\nI also speak at confrences, so far exclusively about tests.\nIf you\u0026rsquo;d like to get notified or talk to me, please follow / ping me on twitter / x or linkedin.\n","permalink":"https://shaigeva.com/about/","summary":"\u003cdiv style=\"position: relative; display: inline-block;\"\u003e\n  \u003cimg src=\"/shai_mic_cover.jpg\" alt=\"Profile pic\" title=\"Profile pic\" style=\"margin:0; display: block; width: 100%;\" /\u003e\n  \u003cdiv style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, rgba(0, 0, 0, 0.1) 70%, rgba(0, 0, 0, 0.7) 100%); pointer-events: none;\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eMy name is Shai Geva.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;ve been creating software for humans, with humans, for over 20 years.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m mostly a builder, but have also played more \u0026ldquo;high level roles\u0026rdquo;, like product and management (my current position is\ntech-lead at \u003ca href=\"https://www.sayata.com/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eSayata\u003c/a\u003e).\u003c/p\u003e","title":"About"},{"content":"(this post is part of a series about good testing practices)\nThis is a \u0026ldquo;warm-up footgun\u0026rdquo; to the blog post series.\nThe easiest way to shoot yourself in the foot, testing-wise, is to have no tests at all.\nIn my experience, writing any tests often helps us - even if these tests are not well-written, and even if they\u0026rsquo;re just a drop in the sea.\nThere are a few reasons I noticed, why moving from no tests at all to even one test for some area of the code is useful.\nCode changes around hotspots Code changes are not uniformly distributed.\nIf we have a signifcantly-sized code base and we look 6 months to the past, we will see that changes tend to happen in the same places. We don\u0026rsquo;t change all types of features all the time and all types of infrastructure all the time.\nFeatures tend to evolve iteratively, and bugs that are introduced are statistically fixed in the following weeks or months.\nSo chances are - if you\u0026rsquo;ve changed an area of the code today, you will change it again in the next month.\nFor automated tests, what this means is that adding tests for the code we\u0026rsquo;re working on now tends to have a much larger impact than we might assume, because they are likely to protect us in the next few weeks.\nZero to one As with many, many considerations in any kind of project - making the first move is an uncomfortable \u0026ldquo;awkwardness\u0026rdquo; - we don\u0026rsquo;t exactly know how to do it.\nBut once we have a single test, we have an initial \u0026ldquo;paved road\u0026rdquo;, and we can keep improving in iterative steps, which is far easier.\nIf you never start, it\u0026rsquo;s 100% you\u0026rsquo;ll stay at zero Maybe the first test you\u0026rsquo;re writing will be the last.\nBut maybe it won\u0026rsquo;t, and it\u0026rsquo;ll lead to way to having a much better developer experience.\nIf you never write the first test, you will definitely not write tests number 2, 3 and 20.\nMy own experience I can\u0026rsquo;t back this up with anything besides \u0026ldquo;I\u0026rsquo;ve seen this enough, that\u0026rsquo;s the way it is\u0026rdquo; - but I can tell you that I almost never regretted writing the first few tests for a piece of code.\nIn almost all cases, it did help me improve the code design and prevent bugs.\nConclusion Start with something easy and simple, as long as you start :)\nnext post: Untested Tests \u0026gt;\u0026gt; ","permalink":"https://shaigeva.com/posts/10_footguns/01_there_are_no_tests/","summary":"\u003cp\u003e(this post is part of a \u003ca href=\"https://shaigeva.com/posts/10_footguns/ten_footguns/\"\u003eseries\u003c/a\u003e about good testing practices)\u003c/p\u003e\n\u003cp\u003eThis is a \u0026ldquo;warm-up footgun\u0026rdquo; to the blog post series.\u003c/p\u003e\n\u003cp\u003eThe easiest way to shoot yourself in the foot, testing-wise, is to have no tests at all.\u003c/p\u003e\n\u003cp\u003eIn my experience, writing any tests often helps us - even if these tests are not well-written, and even if they\u0026rsquo;re just a drop in the sea.\u003c/p\u003e\n\u003cp\u003eThere are a few reasons I noticed, why moving from no tests at all to even one test for some area of the code is useful.\u003c/p\u003e","title":"Footgun #1 - There Are No Tests"},{"content":"10 Ways To Shoot Yourself In The Foot With Tests - PyCon-IL 2024 (Hebrew) (English version below)\nThe talk shares hard-learned advice about how to avoid getting yourself in trouble with tests.\nSlides: Slideshare PyCon IL 2024\n10 Ways To Shoot Yourself In The Foot With Tests - PyCon-US 2023 (English) Given at Salt Lake City, Utah. The talk shares hard-learned advice about how to avoid getting yourself in trouble with tests.\nProperty-based testing - PyWeb-IL zoom meetup (Hebrew) General intro to property-based testing. Similar to the below talk but more python oriented, with more concrete examples. (and in zoom)\nProperty-based testing - Reversim2021 convention talk (Hebrew) General intro to property-based testing (not language specific)\n","permalink":"https://shaigeva.com/talks/","summary":"\u003ch1 id=\"10-ways-to-shoot-yourself-in-the-foot-with-tests---pycon-il-2024-hebrew\"\u003e10 Ways To Shoot Yourself In The Foot With Tests - PyCon-IL 2024 (Hebrew)\u003c/h1\u003e\n\u003cp\u003e(English version below)\u003c/p\u003e\n\u003cp\u003eThe talk shares hard-learned advice about how to avoid getting yourself in trouble with tests.\u003c/p\u003e\n\u003cp\u003eSlides: \u003ca href=\"https://bit.ly/testing_footguns_pycon_il_2024\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eSlideshare PyCon IL 2024\u003c/a\u003e\u003c/p\u003e\n\n\n    \n    \u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/k-vDmoPT84g?autoplay=0\u0026controls=1\u0026end=0\u0026loop=0\u0026mute=0\u0026start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\n      \u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003ch1 id=\"10-ways-to-shoot-yourself-in-the-foot-with-tests---pycon-us-2023-english\"\u003e10 Ways To Shoot Yourself In The Foot With Tests - PyCon-US 2023 (English)\u003c/h1\u003e\n\u003cp\u003eGiven at Salt Lake City, Utah.\nThe talk shares hard-learned advice about how to avoid getting yourself in trouble with tests.\u003c/p\u003e","title":"Talks"}]