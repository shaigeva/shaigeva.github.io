<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Moving past vibe-coding? In Search of real-world AI-First Development: AI-First Design Patterns and Frameworks (blog post series) | Shai Geva</title>
<meta name="keywords" content="">
<meta name="description" content="(first post in a series)
Like many others, I spent a lot of time thinking about AI and software development.
I belong to the camp that believes that AI is a total paradigm shift - it&rsquo;ll redefine the ecosystem and what it means to
create software, and it&rsquo;ll be the deepest change we have seen to date.
My own &ldquo;flavor&rdquo; of thinking about this is to try, from an engineering / implementation perspective, to understand
what that change could look like.
This blog series will dig into this and share my thoughts and conclusions from experimentation.
I&rsquo;ll talk about both:">
<meta name="author" content="Shai Geva">
<link rel="canonical" href="https://shaigeva.com/posts/ai_frameworks/01_ai_frameworks_intro/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://shaigeva.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://shaigeva.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://shaigeva.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://shaigeva.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://shaigeva.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://shaigeva.com/posts/ai_frameworks/01_ai_frameworks_intro/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWC9X8YE9C"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-YWC9X8YE9C');
        }
      </script><meta property="og:title" content="Moving past vibe-coding? In Search of real-world AI-First Development: AI-First Design Patterns and Frameworks (blog post series)" />
<meta property="og:description" content="(first post in a series)
Like many others, I spent a lot of time thinking about AI and software development.
I belong to the camp that believes that AI is a total paradigm shift - it&rsquo;ll redefine the ecosystem and what it means to
create software, and it&rsquo;ll be the deepest change we have seen to date.
My own &ldquo;flavor&rdquo; of thinking about this is to try, from an engineering / implementation perspective, to understand
what that change could look like.
This blog series will dig into this and share my thoughts and conclusions from experimentation.
I&rsquo;ll talk about both:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://shaigeva.com/posts/ai_frameworks/01_ai_frameworks_intro/" />
<meta property="og:image" content="https://shaigeva.com/ai_frameworks/robot_feedback_loop_matrix.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-06-20T13:01:56+03:00" />
<meta property="article:modified_time" content="2025-06-20T13:01:56+03:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://shaigeva.com/ai_frameworks/robot_feedback_loop_matrix.png" />
<meta name="twitter:title" content="Moving past vibe-coding? In Search of real-world AI-First Development: AI-First Design Patterns and Frameworks (blog post series)"/>
<meta name="twitter:description" content="(first post in a series)
Like many others, I spent a lot of time thinking about AI and software development.
I belong to the camp that believes that AI is a total paradigm shift - it&rsquo;ll redefine the ecosystem and what it means to
create software, and it&rsquo;ll be the deepest change we have seen to date.
My own &ldquo;flavor&rdquo; of thinking about this is to try, from an engineering / implementation perspective, to understand
what that change could look like.
This blog series will dig into this and share my thoughts and conclusions from experimentation.
I&rsquo;ll talk about both:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://shaigeva.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Moving past vibe-coding? In Search of real-world AI-First Development: AI-First Design Patterns and Frameworks (blog post series)",
      "item": "https://shaigeva.com/posts/ai_frameworks/01_ai_frameworks_intro/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Moving past vibe-coding? In Search of real-world AI-First Development: AI-First Design Patterns and Frameworks (blog post series)",
  "name": "Moving past vibe-coding? In Search of real-world AI-First Development: AI-First Design Patterns and Frameworks (blog post series)",
  "description": "(first post in a series)\nLike many others, I spent a lot of time thinking about AI and software development.\nI belong to the camp that believes that AI is a total paradigm shift - it\u0026rsquo;ll redefine the ecosystem and what it means to create software, and it\u0026rsquo;ll be the deepest change we have seen to date.\nMy own \u0026ldquo;flavor\u0026rdquo; of thinking about this is to try, from an engineering / implementation perspective, to understand what that change could look like.\nThis blog series will dig into this and share my thoughts and conclusions from experimentation.\nI\u0026rsquo;ll talk about both:\n",
  "keywords": [
    
  ],
  "articleBody": "(first post in a series)\nLike many others, I spent a lot of time thinking about AI and software development.\nI belong to the camp that believes that AI is a total paradigm shift - it’ll redefine the ecosystem and what it means to create software, and it’ll be the deepest change we have seen to date.\nMy own “flavor” of thinking about this is to try, from an engineering / implementation perspective, to understand what that change could look like.\nThis blog series will dig into this and share my thoughts and conclusions from experimentation.\nI’ll talk about both:\nWhat can we already do today? Concrete, pragmatic practices we can use right now to make ourselves faster. And more theoretically: What would need to be different in how we work so in the future (few years?), everything will indeed be different and much more productive? My hope is that these posts will help enthusiastic devs boost their productivity, and to contribute to the general conversation around AI and coding.\nIn this intro post, I’m describing the general concept, with some high-level examples (most of the series will be low-level and technical).\nCreating maintainable software By now (2025-06), the term vibe coding has been with us for a few months, and tools / platforms have been here for quite a bit more.\nAI coding assistants already help us in many ways, including creating impressive projects to a level that would seem science fiction just a few years ago.\nWe’re seeing fast and significant improvement in many areas of dev work.\nHowever, the effect is far less impressive for what is the bulk of dev work today - ongoing work on large code bases.\nDon’t get me wrong - it’s great, it’s an amazing productivity boost, but it’s not the same categorical change that we’re seeing when vibe coding smaller non-production-grade projects.\nWe all know that in most real-world non-small code bases, on most changes we make, AI just doesn’t speed us up 10x right now.\nIn practice, while this does happen sometimes - at the moment it’s only “here and there”. It’s not the general case.\nThe easy path is to adjust the code to the AI (AI-first / AI-native / AI-driven) I believe that huge improvements to productivity on large code bases are possible with the current generation of LLMs.\nMore than 10x.\nAnd I believe that part of what we need to do in order to get there in the long run is to build AI compatibility into the code-base from the ground up (this approach is usually called AI-first / AI-native / AI-driven development).\nFor the shorter-term, this can be “done in pieces” - make a certain part, or certain aspect of the code base be “AI-friendly”.\nWhy? Well, AI has different trade-offs than human teams in what is easy or hard when creating software.\nSo if we want AI to 10x what it can do (and what we can do), the easiest way is to build the code in a way that fits the AI’s tradeoffs.\nIn other words, we need to have definitions that dictate aspects of the code and workflow, which are AI-friendly.\nThese can be very general and very simple (like “use meaningful variable names”), or very use-case specific, like how to use a specific framework in a specific language.\nSo anything might be relevant - workflow, specifications, tech stack, packages, tooling, coding conventions, code design, testing techniques, etc. etc.\nThe central point here is that we will not “continue to write code like we do now plus add AI”, but that we’ll see substantial changes to all of these.\nDesign patterns I’ll refer to these aspects of the code and workflow as “design patterns”.\nI’m using this term because there’s no real established terminology. Some of the things I’ll talk about are more “practices”, some are more “coding conventions” and some can only be called “design patterns”. So I’m going with the term that I think is best at conveying that:\nThe way we do code is different, it’s not just how we prompt or the tools we use\". It’s a design approach. It’s part of the design of our code, our architecture, our workflow. A key part of being productive with AI, I believe, is to master these.\nHow should we structure the code so AI can work with it well? What abstraction layers? What will the APIs between different components look like? Which tests should we have, at which layers?\nI’ll talk about examples (and do some POCs) of such design patterns in this series.\nIt’s worth mentioning that most (or all) concepts are not going to be too exotic - the approaches we’ll explore are variations of established industry techniques.\nAn experienced developer will be familiar with many of them.\nThe point here is less to invent new ideas, and more to examine the option of applying what already exists in a systematic way to the general problem of programming with AI.\nFrameworks Individual design patterns are nice, and will be very beneficial for those that learn them.\nI believe, however, that the best way forward is what I think of as AI-first frameworks.\nVery loosely, what I mean by a framework is a “combo” of these design patterns plus relevant tooling.\nIt can be something like\nA Python backend service Enforces type annotations (Python generally allows, but doesn’t require, static types. So a framework could require it). Using a spceific backend library (e.g. Python’s FastAPI) Has pre-defined layers of abstraction. E.g. “there is a DAL (data access layer), and all its APIs only receive and return immutable data structures”. There are pre-defined layers where tests are written, and they have specific technical requirements. E.g. “the DAL must have a robust test suite for testing every single workflow. That test suite only uses the DAL API (can’t use SQL or an ORM directly)”. etc. etc. (there will probably be dozens of these, incl. specific commands to how we run some tools, AI agent rule files and whatever’s needed to enforce the specification) These frameworks will create a “cohesive whole” that an AI agent can work with effectively.\nFor example, definitions in the spirit of what I gave above (but, of course, much more explicit and robust) would force the AI agent to create a well-defined set of all possible interactions with the database and have tests that thoroughly cover them.\nBut why do we need these “frameworks”?\nI think that having each team hand-craft their own AI-compatible practices for their code base is kind of like having each backend team develop their own web framework from low-level http libraries, just because “we want it to be tailored to our use case”.\nIt can be done, but we all understand it’s not a good idea. It’s very expensive and the result will suck most of the time.\nI think it’ll be much better if the industry will “think of it” a little bit like we think of web development today: there will be common (open source?) frameworks / tool-sets created by experts, and most teams will use a combination of a few standard options, plus customization where actually needed.\nTL;DR There are a lot of pieces to this, and it’ll take a while until I manage to release blog posts covering everything I have in mind, so it’s worth it to give a very high level view of the approach here:\nPrinciples The most significant mental models here are the feedback loop and the bug funnel.\nThe bug funnel (it’s not really just bugs - also features etc., but “bug funnel” is easy to think about) is the concept that when code is written (by a human or AI), it sometimes contains things that are not desirable.\nAs that code “moves forward in the software lifecycle” (compilers, linters, various tests, review, etc. etc.), some of these bugs are discovered at every step and get filtered out.\nBugs that are discovered earlier in the “funnel” are cheaper than bugs found later.\nIn other words, it’s a very good idea to “shift-left” bugs in the bug funnel.\nThe feedback loop is what we all know - planning, doing, verifying and then doing it again and again until we’re done.\nA fast and effective feedback loop has always been one of the most significant things in the process of creating software, and AI assistants will magnify that by orders of magnitude.\nOur main objective is to make the human feedback loop “better” (faster, easier, more effective).\nAnd the main way that we’ll help the human feedback loop is by giving the AI agents their own internal feedback loop. We’ll work very hard to enable the agent to plan, make changes and then verify them itself and auto-heal them. So that it’ll give the result to a human only after it’s done and “filtered out” all the bugs it can.\nIn other words, the “star of the show” is going to be the ability to create fast feedback loops that are effective at both creating new things and shifting-left bugs in the bug funnel.\nMy main focus will be on the verification part - allowing the AI to check the changes it makes.\nWe’ll explore a bunch of directions like linting, static typing approaches, ideas like automatic screenshots and LLM automatic reviews. And mostly - A LOT of code design and testing techniques.\nPractices / techniques As mentioned, our main technical objective will be a fast AI-internal feedback loop that “rule-out” as many “bugs” as possible, as quickly as possible.\n“Quick” means that almost all “bugs” can be ruled-out in a few seconds by the AI without human intervention.\nThere will, of course, also be slower verifications like e2e tests - but most bugs should be caught by the faster tests, earlier in the process.\nThis has very strong implications on what practices are expected to be effective.\nFor instance:\nWe need a setup that allows the AI agent to run code to check the changes it makes (sometimes the entire program, sometiems only tests). Having an LLM just “review” written code just ain’t gonna cut it. But - we should try hard to verify things about the code even without running it (as a test or otherwise). Examples: Static typing, of course. This can be taken further than most people are aware and AI is a good match for this. Preference for pure functions where applicable. Have simulators for most side-effects, especially those that we don’t directly control. A simulator is a simplified implementation of some part of a real thing, that has a very similar behavior. For example, a DB table can be a list of in-memory tuples plus some wrappers. AKA “fakes” in standard test-speak. Required because side-effects might be unsafe, unreliable, uncontrollable and slow, but we must allow the AI to run code (either as a test or not) in a way that is safe-enough, reliable-enough, controllable-enough and fast-enough. This is an almost logical necessity, even though it’s not “part of the conversation” now at all (I’m not sure I’ve ever seen it mentioned in the AI-building conversation, actually). Without this, everything’s going to be much harder. I will be talking a lot about this, since bringing this down to reality is a challenge. Very strong preference towards small building blocks that compose into larger components where possible (stronger than would be appropriate for many human teams). This helps to have “divide and conquer” of bugs, leaving as few bugs as possible to the more complex, slower tests. Lastly, of course - we need to actually use all of this to design and create coding+testing strategies that have a good ROI. This point is the most vague, the most nuanced, but also probably the most important because it’s necessary, and I think it’s pretty difficult. I’ve had these ideas running around in my head for while and at least for me they are interesting, so I felt like it’s time to share.\nI hope you find this useful, or at least interesting.\nPing me on social (twitter / x, linkedin) and let me know!\nIn the next post (coming in a week, I hope), I’ll give an example of what an internal AI feedback loop looks like on a small project, and start looking at some of the more basic techniques.\n",
  "wordCount" : "2061",
  "inLanguage": "en",
  "image":"https://shaigeva.com/ai_frameworks/robot_feedback_loop_matrix.png","datePublished": "2025-06-20T13:01:56+03:00",
  "dateModified": "2025-06-20T13:01:56+03:00",
  "author":{
    "@type": "Person",
    "name": "Shai Geva"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://shaigeva.com/posts/ai_frameworks/01_ai_frameworks_intro/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Shai Geva",
    "logo": {
      "@type": "ImageObject",
      "url": "https://shaigeva.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://shaigeva.com/" accesskey="h" title="Shai Geva (Alt + H)">Shai Geva</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://shaigeva.com/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://shaigeva.com/talks" title="Talks">
                    <span>Talks</span>
                </a>
            </li>
            <li>
                <a href="https://shaigeva.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Moving past vibe-coding? In Search of real-world AI-First Development: AI-First Design Patterns and Frameworks (blog post series)
    </h1>
    <div class="post-meta"><span title='2025-06-20 13:01:56 +0300 IDT'>June 20, 2025</span>&nbsp;·&nbsp;Shai Geva

</div>
  </header> 
<figure class="entry-cover"><img loading="eager" src="https://shaigeva.com/ai_frameworks/robot_feedback_loop_matrix.png" alt="">
        
</figure>
  <div class="post-content"><p>(first post in a series)</p>
<p>Like many others, I spent a lot of time thinking about AI and software development.</p>
<p>I belong to the camp that believes that AI is a total paradigm shift - it&rsquo;ll redefine the ecosystem and what it means to
create software, and it&rsquo;ll be the deepest change we have seen to date.</p>
<p>My own &ldquo;flavor&rdquo; of thinking about this is to try, from an <strong>engineering / implementation</strong> perspective, to understand
what that change could look like.<br>
This blog series will dig into this and share my thoughts and conclusions from experimentation.<br>
I&rsquo;ll talk about both:</p>
<ul>
<li>What can we already do today? Concrete, pragmatic practices we can use right now to make ourselves faster.</li>
<li>And more theoretically: What would need to be different in how we work so in the future (few years?), everything will indeed be different and
much more productive?</li>
</ul>
<p>My hope is that these posts will help enthusiastic devs boost their productivity, and to contribute to the general
conversation around AI and coding.</p>
<p>In this intro post, I&rsquo;m describing the general concept, with some high-level examples (most of the series will be
low-level and technical).</p>
<h2 id="creating-maintainable-software">Creating maintainable software<a hidden class="anchor" aria-hidden="true" href="#creating-maintainable-software">#</a></h2>
<p>By now (2025-06), the term vibe coding has been with us for a few months, and tools / platforms have been here for quite
a bit more.<br>
AI coding assistants already help us in many ways, including creating impressive projects
to a level that would seem science fiction just a few years ago.<br>
We&rsquo;re seeing fast and significant improvement in many areas of dev work.</p>
<p>However, the effect is far less impressive for what is the bulk of dev work today - ongoing work on large code bases.<br>
Don&rsquo;t get me wrong - it&rsquo;s great, it&rsquo;s an amazing productivity boost, but it&rsquo;s not the same categorical change that we&rsquo;re
seeing when vibe coding smaller non-production-grade projects.</p>
<p>We all know that in most real-world non-small code bases, on most changes we make, AI just doesn&rsquo;t speed us up 10x right
now.<br>
In practice, while this does happen sometimes - at the moment it&rsquo;s only &ldquo;here and there&rdquo;. It&rsquo;s not the general case.</p>
<h2 id="the-easy-path-is-to-adjust-the-code-to-the-ai-ai-first--ai-native--ai-driven">The easy path is to adjust the code to the AI (AI-first / AI-native / AI-driven)<a hidden class="anchor" aria-hidden="true" href="#the-easy-path-is-to-adjust-the-code-to-the-ai-ai-first--ai-native--ai-driven">#</a></h2>
<p>I believe that huge improvements to productivity on large code bases are possible with the current generation of LLMs.<br>
More than 10x.</p>
<p>And I believe that part of what we need to do in order to get there in the long run is to build AI compatibility into
the code-base from the ground up (this approach is usually called AI-first / AI-native / AI-driven development).<br>
For the shorter-term, this can be &ldquo;done in pieces&rdquo; - make a certain part, or certain aspect of the code base be
&ldquo;AI-friendly&rdquo;.</p>
<p>Why? Well, AI has different trade-offs than human teams in what is easy or hard when creating software.<br>
So if we want AI to 10x what it can do (and what we can do), the easiest way is to build the code in a way that fits the
AI&rsquo;s tradeoffs.</p>
<p>In other words, we need to have definitions that dictate aspects of the code and workflow, which are AI-friendly.<br>
These can be very general and very simple (like &ldquo;use meaningful variable names&rdquo;), or very use-case specific, like how to
use a specific framework in a specific language.</p>
<p>So anything might be relevant - workflow, specifications, tech stack, packages, tooling, coding conventions,
code design, testing techniques, etc. etc.<br>
The central point here is that we will not &ldquo;continue to write code like we do now plus add AI&rdquo;, but that we&rsquo;ll see
substantial changes to all of these.</p>
<h2 id="design-patterns">Design patterns<a hidden class="anchor" aria-hidden="true" href="#design-patterns">#</a></h2>
<p>I&rsquo;ll refer to these aspects of the code and workflow as &ldquo;design patterns&rdquo;.<br>
I&rsquo;m using this term because there&rsquo;s no real established terminology. Some of the
things I&rsquo;ll talk about are more &ldquo;practices&rdquo;, some are more &ldquo;coding conventions&rdquo; and some can only be called &ldquo;design
patterns&rdquo;. So I&rsquo;m going with the term that I think is best at conveying that:</p>
<ol>
<li>The way we do code is different, it&rsquo;s not just how we prompt or the tools we use&quot;.</li>
<li>It&rsquo;s a <strong>design</strong> approach. It&rsquo;s part of the design of our code, our architecture, our workflow.</li>
</ol>
<p>A key part of being productive with AI, I believe, is to master these.<br>
How should we structure the code so AI can work with it well?
What abstraction layers? What will the APIs between different components look like?
Which tests should we have, at which layers?</p>
<p>I&rsquo;ll talk about examples (and do some POCs) of such design patterns in this series.</p>
<p>It&rsquo;s worth mentioning that most (or all) concepts are not going to be too exotic - the approaches we&rsquo;ll explore are
variations of established industry techniques.<br>
An experienced developer will be familiar with many of them.<br>
The point here is less to invent new ideas, and more to examine the option of applying what already exists in a
systematic way to the general problem of programming with AI.</p>
<h2 id="frameworks">Frameworks<a hidden class="anchor" aria-hidden="true" href="#frameworks">#</a></h2>
<p>Individual design patterns are nice, and will be very beneficial for those that learn them.</p>
<p>I believe, however, that the best way forward is what I think of as <strong>AI-first frameworks</strong>.</p>
<p>Very loosely, what I mean by a framework is a &ldquo;combo&rdquo; of these design patterns plus relevant tooling.<br>
It can be something like</p>
<ul>
<li>A Python backend service</li>
<li>Enforces type annotations (Python generally allows, but doesn&rsquo;t require, static types. So a framework could
require it).</li>
<li>Using a spceific backend library (e.g. Python&rsquo;s FastAPI)</li>
<li>Has pre-defined layers of abstraction. E.g. &ldquo;there is a DAL (data access layer), and all its APIs only receive and
return immutable data structures&rdquo;.</li>
<li>There are pre-defined layers where tests are written, and they have specific technical requirements. E.g. &ldquo;the DAL
must have a robust test suite for testing every single workflow. That test suite only uses the DAL API (can&rsquo;t use SQL or
an ORM directly)&rdquo;.</li>
<li>etc. etc. (there will probably be dozens of these, incl. specific commands to how we run some tools, AI agent rule
files and whatever&rsquo;s needed to enforce the specification)</li>
</ul>
<p>These frameworks will create a &ldquo;cohesive whole&rdquo; that an AI agent can work with effectively.<br>
For example, definitions in the spirit of what I gave above (but, of course, much more explicit and robust) would force
the AI agent to create a well-defined set of all possible interactions with the database and have tests that thoroughly
cover them.</p>
<p>But why do we need these &ldquo;frameworks&rdquo;?<br>
I think that having each team hand-craft their own AI-compatible practices for their code base is kind of like having each
backend team develop their own web framework from low-level http libraries, just because &ldquo;we want it to be tailored to
our use case&rdquo;.<br>
It can be done, but we all understand it&rsquo;s not a good idea. It&rsquo;s very expensive and the result will suck most of the
time.<br>
I think it&rsquo;ll be much better if the industry will &ldquo;think of it&rdquo; a little bit like we think of web development today:
there will be common (open source?) frameworks / tool-sets created by experts, and most teams will use a
combination of a few standard options, plus customization where actually needed.</p>
<h2 id="tldr">TL;DR<a hidden class="anchor" aria-hidden="true" href="#tldr">#</a></h2>
<p>There are a lot of pieces to this, and it&rsquo;ll take a while until I manage to release blog posts covering everything I
have in mind, so it&rsquo;s worth it to give a very high level view of the approach here:</p>
<h3 id="principles">Principles<a hidden class="anchor" aria-hidden="true" href="#principles">#</a></h3>
<p>The most significant mental models here are the feedback loop and the bug funnel.</p>
<p>The bug funnel (it&rsquo;s not really just bugs - also features etc., but &ldquo;bug funnel&rdquo; is easy to think about) is the concept
that when code is written (by a human or AI), it sometimes contains things that are not desirable.<br>
As that code &ldquo;moves forward in the software lifecycle&rdquo; (compilers, linters, various tests, review, etc. etc.), some of
these bugs are discovered at every step and get filtered out.<br>
Bugs that are discovered earlier in the &ldquo;funnel&rdquo; are cheaper than bugs found later.<br>
In other words, it&rsquo;s a very good idea to &ldquo;shift-left&rdquo; bugs in the bug funnel.</p>
<p>The feedback loop is what we all know - planning, doing, verifying and then doing it again and again until we&rsquo;re done.<br>
A fast and effective feedback loop has always been one of the most significant things in the process of creating
software, and AI assistants will magnify that by orders of magnitude.<br>
Our main objective is to make the human feedback loop &ldquo;better&rdquo; (faster, easier, more effective).<br>
And the main way that we&rsquo;ll help the human feedback loop is by giving the AI agents their own internal feedback loop.
We&rsquo;ll work very hard to enable the agent to plan, make changes and then verify them itself and auto-heal them. So that
it&rsquo;ll give the result to a human only after it&rsquo;s done and &ldquo;filtered out&rdquo; all the bugs it can.</p>
<p>In other words, the &ldquo;star of the show&rdquo; is going to be the ability to create fast feedback loops that are effective at
both creating new things and shifting-left bugs in the bug funnel.</p>
<p>My main focus will be on the verification part - allowing the AI to check the changes it makes.<br>
We&rsquo;ll explore a bunch of directions like linting, static typing approaches, ideas like
automatic screenshots and LLM automatic reviews. And mostly - A LOT of code design and testing techniques.</p>
<h3 id="practices--techniques">Practices / techniques<a hidden class="anchor" aria-hidden="true" href="#practices--techniques">#</a></h3>
<p>As mentioned, our main technical objective will be a fast AI-internal feedback loop that &ldquo;rule-out&rdquo; as many &ldquo;bugs&rdquo; as
possible, as quickly as possible.<br>
&ldquo;Quick&rdquo; means that almost all &ldquo;bugs&rdquo; can be ruled-out in a few seconds by the AI without human intervention.<br>
There will, of course, also be slower verifications like e2e tests - but most bugs should be caught by the faster tests,
earlier in the process.</p>
<p>This has very strong implications on what practices are expected to be effective.<br>
For instance:</p>
<ol>
<li>We need a setup that allows the AI agent to run code to check the changes it makes (sometimes the entire program,
sometiems only tests). Having an LLM just &ldquo;review&rdquo; written code just ain&rsquo;t gonna cut it.</li>
<li>But - we should try hard to verify things about the code even without running it (as a test or otherwise). Examples:
<ol>
<li>Static typing, of course. This can be taken further than most people are aware and AI is a good match for this.</li>
<li>Preference for pure functions where applicable.</li>
</ol>
</li>
<li>Have simulators for most side-effects, especially those that we don&rsquo;t directly control.
<ol>
<li>A simulator is a simplified implementation of some part of a real thing, that has a very similar behavior.
For example, a DB table can be a list of in-memory tuples plus some wrappers.</li>
<li>AKA &ldquo;fakes&rdquo; in standard test-speak.</li>
<li>Required because side-effects might be unsafe, unreliable, uncontrollable and slow, but we must allow the AI to
run code (either as a test or not) in a way that is safe-enough, reliable-enough, controllable-enough and
fast-enough.</li>
<li>This is an almost logical necessity, even though it&rsquo;s not &ldquo;part of the conversation&rdquo; now at all (I&rsquo;m not sure
I&rsquo;ve ever seen it mentioned in the AI-building conversation, actually). Without this, everything&rsquo;s going to be much
harder.</li>
<li>I will be talking a lot about this, since bringing this down to reality is a challenge.</li>
</ol>
</li>
<li>Very strong preference towards small building blocks that compose into larger components where possible (stronger
than would be appropriate for many human teams). This helps to have &ldquo;divide and conquer&rdquo; of bugs, leaving as
few bugs as possible to the more complex, slower tests.</li>
<li>Lastly, of course - we need to actually use all of this to design and create coding+testing strategies that have a
good ROI. This point is the most vague, the most nuanced, but also probably the most important because it&rsquo;s
necessary, and I think it&rsquo;s pretty difficult.</li>
</ol>
<hr>
<p>I&rsquo;ve had these ideas running around in my head for while and at least for me they are interesting, so I felt like
it&rsquo;s time to share.</p>
<p>I hope you find this useful, or at least interesting.<br>
Ping me on social (<a href="https://x.com/shai_ge" target="_blank" rel="noopener noreferrer">twitter / x</a>, <a href="https://www.linkedin.com/in/shai-geva-bb51404/" target="_blank" rel="noopener noreferrer">linkedin</a>) and let me know!</p>
<hr>
<p>In the next post (coming in a week, I hope), I&rsquo;ll give an example of what an internal AI feedback loop looks like on a small project, and start looking at some of the more basic techniques.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://shaigeva.com/">Shai Geva</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
