<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Footgun #7 - Improper Test Scope | Shai Geva</title>
<meta name="keywords" content="">
<meta name="description" content="
This mini-post is part of a series about good testing practices, which I also presented at a couple of conferences.

Here it is in PyCon US 2023


The root cause of many testing problems is improper test scope, i.e. that their boundaries aren&rsquo;t appropriate.
Test a cohesive whole - complete story
My approach here is that a test should verify a cohesive whole, a &ldquo;complete story&rdquo;.
It can be a large story like an e2e test or a small story that&rsquo;s part of a bigger story, like a custom sorting function
that something else uses.
As long as it&rsquo;s something self-contained - something whole, it might be worth testing.">
<meta name="author" content="Shai Geva">
<link rel="canonical" href="https://shaigeva.com/posts/10_footguns/07_improper_test_scope/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.ad7e9ed672bfa63aa62f2a9523f793e89f751a105296a152608bd1ccabf63b08.css" integrity="sha256-rX6e1nK/pjqmLyqVI/eT6J91GhBSlqFSYIvRzKv2Owg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://shaigeva.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://shaigeva.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://shaigeva.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://shaigeva.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://shaigeva.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://shaigeva.com/posts/10_footguns/07_improper_test_scope/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWC9X8YE9C"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-YWC9X8YE9C');
        }
      </script><meta property="og:url" content="https://shaigeva.com/posts/10_footguns/07_improper_test_scope/">
  <meta property="og:site_name" content="Shai Geva">
  <meta property="og:title" content="Footgun #7 - Improper Test Scope">
  <meta property="og:description" content=" This mini-post is part of a series about good testing practices, which I also presented at a couple of conferences. Here it is in PyCon US 2023 The root cause of many testing problems is improper test scope, i.e. that their boundaries aren’t appropriate.
Test a cohesive whole - complete story My approach here is that a test should verify a cohesive whole, a “complete story”.
It can be a large story like an e2e test or a small story that’s part of a bigger story, like a custom sorting function that something else uses.
As long as it’s something self-contained - something whole, it might be worth testing.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-16T10:16:56+03:00">
    <meta property="article:modified_time" content="2025-05-16T10:16:56+03:00">
    <meta property="og:image" content="https://shaigeva.com/10_footguns/10_footguns_07_improper_test_scope.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://shaigeva.com/10_footguns/10_footguns_07_improper_test_scope.png">
<meta name="twitter:title" content="Footgun #7 - Improper Test Scope">
<meta name="twitter:description" content="
This mini-post is part of a series about good testing practices, which I also presented at a couple of conferences.

Here it is in PyCon US 2023


The root cause of many testing problems is improper test scope, i.e. that their boundaries aren&rsquo;t appropriate.
Test a cohesive whole - complete story
My approach here is that a test should verify a cohesive whole, a &ldquo;complete story&rdquo;.
It can be a large story like an e2e test or a small story that&rsquo;s part of a bigger story, like a custom sorting function
that something else uses.
As long as it&rsquo;s something self-contained - something whole, it might be worth testing.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://shaigeva.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Footgun #7 - Improper Test Scope",
      "item": "https://shaigeva.com/posts/10_footguns/07_improper_test_scope/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Footgun #7 - Improper Test Scope",
  "name": "Footgun #7 - Improper Test Scope",
  "description": " This mini-post is part of a series about good testing practices, which I also presented at a couple of conferences. Here it is in PyCon US 2023 The root cause of many testing problems is improper test scope, i.e. that their boundaries aren\u0026rsquo;t appropriate.\nTest a cohesive whole - complete story My approach here is that a test should verify a cohesive whole, a \u0026ldquo;complete story\u0026rdquo;.\nIt can be a large story like an e2e test or a small story that\u0026rsquo;s part of a bigger story, like a custom sorting function that something else uses.\nAs long as it\u0026rsquo;s something self-contained - something whole, it might be worth testing.\n",
  "keywords": [
    
  ],
  "articleBody": " This mini-post is part of a series about good testing practices, which I also presented at a couple of conferences. Here it is in PyCon US 2023 The root cause of many testing problems is improper test scope, i.e. that their boundaries aren’t appropriate.\nTest a cohesive whole - complete story My approach here is that a test should verify a cohesive whole, a “complete story”.\nIt can be a large story like an e2e test or a small story that’s part of a bigger story, like a custom sorting function that something else uses.\nAs long as it’s something self-contained - something whole, it might be worth testing.\nIt’s very close to the notion of “testing implementation instead of behavior”, but I find that this phrasing is more useful.\nComparing two alternative test suites Let’s say we’re building a Book Store web service, and it uses a DB.\n┌─────────────────────┐ ┌─────────────────────┐ │ │ │ │ │ Book Store │ --\u003e │ MySQL │ │ │ │ │ └─────────────────────┘ └─────────────────────┘ We’ll do a small thought experiment.\nWe will consider two alternative test suites - “behavior tests” and “implementation tests”.\nWe will take a possible code change, and we’ll imagine how one of the tests is going to behave - once if there was a bug, and once if everything was correct.\nWe will try to imagine what our life will look like if we would have chosen one test suite or the other.\nAnd we’re going to see that in all cases - it’s the behavior test that gives us what we want.\nWe’ll look at an almost identical test in both test suites.\nThe test verifies that if we edit the description of a book, then it has really been updated.\nPretty simple.\nBoth tests have the same flow -\nCreate a book Edit the book Get the updated description Make the assertion. The behavior test does everything through the external http API, IN THE SAME WAY things would be done in the actual system.\nThe implementation test does some of the things at a lower level. It:\nCreates the book by directly creating a record in the database Checks the updated description through the DB. So the behavior test only looks at the WHAT - It looks at things as they appear from outside.\nThe implementation test also knows about HOW. It knows how the code will change the DB.\nNow, checking the implementation like this will USUALLY be equivalent to the behavior - but not always.\nBut why does this matter to us?\nOur scenario Let’s look at a possible scenario:\nWe’ve had this test suite for a while, maybe even years.\nWe’ve invested a lot in them, and we rely on them.\nAnd today, we’re making a change to optimize the database.\nWe’re moving the description out of the Book table, and into a separate table.\nHowever, we’re not deleting the old field yet - we’ll do that later after all the data has moved to the new table. Let’s say we’re finished with everything else - and it’s time to update the edit-book endpoint.\nWe’ll check what happens if we created a bug, and if we did everything correctly.\nWhat if we created a bug? Now, what if we just FORGOT to update the edit-book endpoint? Completely forgot.\nThe edit-book endpoint now changes the wrong field in the database so behavior-wise, it doesn’t do anything.\nIf this gets to production, then we created a major bug :(\nBug + behavior tests -\u003e good If we chose behavior tests - Since the test only uses the external API, it does not care about implementation details.\nSo if the behavior is wrong, the test will fail, just like it should.\nThe regression bug was prevented.\nEverything’s ok.\nBug + implementation tests -\u003e not good But we chose the implementation test - it looks directly at old description field in the DB.\nWhen we run the test, the old description field will change, just like before, so the test will not fail.\nThe regression bug was not prevented. And a major bug made it to production.\nIt’s not ok. What if we did everything correctly and there’s no bug? On the other side of this, what if we made the change correctly?\nEdit-book now changes the new table instead of the old field.\nNo bug, everything’s fine. No bug + behavior tests -\u003e good If we chose the behavior test - Everything behaves correctly when you just invoke the external endpoints, so the test will pass.\nWe don’t need to do anything.\nNo bug + implementation tests -\u003e not good If we chose the implementation test - The old field is not updated any more, so even though the code is correct, this test will fail.\nThe distinction here is that the failure reason is not that the code is not correct.\nThe test fails because it has become technically invalid.\nSo, we have extra work - we need to figure out whether the failure is real or technical.\nAnd then we’ll need to update the test.\nAlso - because we just changed the test, we now have less confidence in it. We need to learn to trust it again.\nThis is worse on large code bases On large code bases, this can become a real pain.\nYou have to update the tests, even if the code change has no bugs, and sometimes even if the test has nothing to do with the feature you worked on.\nYou end up wasting hours and you hate the test suite.\nSumming up our thought experiment We can see that in every case we looked at - the behavior test was much better.\nCohesive, behavior tests are closer to reality.\nThey are better at protecting us.\nThey create less redundant work.\nAnd we have higher confidence in them in the long run.\nWhat about big changes? One more thing worth mentioning: we looked at an example of a small, incremental change.\nBut sometimes, we need to make BIG changes. SCARY changes.\nIt happens less often but when it happens it’s a big deal.\nLarge DB changes are a good example:\nIn many companies, at some point, the DB doesn’t deal with the scale well.\nWe get stability issues, and we need to make a big change - maybe even move some of the data to a different type of database.\nThat’s when tests are MOST important.\nAnd if we went with behavior level tests - everything will be fine.\nThose same tests that we’ve been running with for 3 years now - we don’t change them.\nWhen they pass, they give us a very strong indication that the logical behavior remains intact.\nBut if we went with Implementation level tests - they all become technically invalid and they all fail.\nWe will need to spend time and effort porting all of them to use the new database.\nBut FAR more importantly: because we’re changing them - we’re not going to trust them enough.\nWE WILL TEST EVERYTHING FROM SCRATCH.\nThis might make the difference between a project that takes a few weeks, and a company-level event that drags out for months while the product has stability issues.\nConclusion I cannot recommend enough:\nTest behavior.\nA cohesive whole, a complete story.\n\u003c\u003c previous post: Testing Too Many Things | next post: Test Doubles Everywhere \u003e\u003e ",
  "wordCount" : "1232",
  "inLanguage": "en",
  "image":"https://shaigeva.com/10_footguns/10_footguns_07_improper_test_scope.png","datePublished": "2025-05-16T10:16:56+03:00",
  "dateModified": "2025-05-16T10:16:56+03:00",
  "author":{
    "@type": "Person",
    "name": "Shai Geva"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://shaigeva.com/posts/10_footguns/07_improper_test_scope/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Shai Geva",
    "logo": {
      "@type": "ImageObject",
      "url": "https://shaigeva.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://shaigeva.com/" accesskey="h" title="Shai Geva (Alt + H)">Shai Geva</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://shaigeva.com/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://shaigeva.com/talks" title="Talks">
                    <span>Talks</span>
                </a>
            </li>
            <li>
                <a href="https://shaigeva.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Footgun #7 - Improper Test Scope
    </h1>
    <div class="post-meta"><span title='2025-05-16 10:16:56 +0300 IDT'>May 16, 2025</span>&nbsp;·&nbsp;<span>Shai Geva</span>

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" src="https://shaigeva.com/10_footguns/10_footguns_07_improper_test_scope.png" alt="">
        
</figure>
  <div class="post-content"><span class="aside">
This mini-post is part of a <a href="/posts/10_footguns/ten_footguns" target="_blank">series</a> about good testing practices, which I also presented at a couple of conferences.
<br>
Here it is in <a href="https://youtu.be/Ub31Ae6S1BY?t=447" target="_blank">PyCon US 2023</a>
</span>

<p>The root cause of many testing problems is improper test scope, i.e. that their boundaries aren&rsquo;t appropriate.</p>
<h1 id="test-a-cohesive-whole---complete-story">Test a cohesive whole - complete story<a hidden class="anchor" aria-hidden="true" href="#test-a-cohesive-whole---complete-story">#</a></h1>
<p>My approach here is that a test should verify a cohesive whole, a &ldquo;complete story&rdquo;.<br>
It can be a large story like an e2e test or a small story that&rsquo;s part of a bigger story, like a custom sorting function
that something else uses.<br>
As long as it&rsquo;s something self-contained - something whole, it might be worth testing.</p>
<p>It’s very close to the notion of “testing implementation instead of behavior”, but I find that this phrasing is more
useful.</p>
<h1 id="comparing-two-alternative-test-suites">Comparing two alternative test suites<a hidden class="anchor" aria-hidden="true" href="#comparing-two-alternative-test-suites">#</a></h1>
<p>Let’s say we&rsquo;re building a Book Store web service, and it uses a DB.</p>
<pre tabindex="0"><code>┌─────────────────────┐      ┌─────────────────────┐
│                     │      │                     │
│     Book Store      │ --&gt;  │       MySQL         │
│                     │      │                     │
└─────────────────────┘      └─────────────────────┘
</code></pre><p>We’ll do a small thought experiment.<br>
We will consider two alternative test suites - “behavior tests” and “implementation tests”.<br>
We will take a possible code change, and we&rsquo;ll imagine how one of the tests is going to behave - once if there was a bug, and
once if everything was correct.</p>
<p>We will try to imagine what our life will look like if we would have chosen one test suite or the other.<br>
And we&rsquo;re going to see that in all cases - it&rsquo;s the behavior test that gives us what we want.</p>
<p><img alt="Alternative test suites" loading="lazy" src="/10_footguns/10_footguns_alternative_test_suites_set_expectation.png"></p>
<p>We&rsquo;ll look at an almost identical test in both test suites.<br>
The test verifies that if we edit the description of a book, then it has really been updated.<br>
Pretty simple.</p>
<p>Both tests have the same flow -</p>
<ul>
<li>Create a book</li>
<li>Edit the book</li>
<li>Get the updated description</li>
<li>Make the assertion.</li>
</ul>
<p>The behavior test does everything through the external http API, IN THE SAME WAY things would be done in the actual system.</p>
<p>The implementation test does some of the things at a lower level. It:</p>
<ul>
<li>Creates the book by directly creating a record in the database</li>
<li>Checks the updated description through the DB.</li>
</ul>
<p><img alt="Behavior test vs implementation test" loading="lazy" src="/10_footguns/10_footguns_show_two_similar_tests.png"></p>
<p>So the behavior test only looks at the WHAT -
It looks at things as they appear from outside.</p>
<p>The implementation test also knows about HOW.
It knows how the code will change the DB.</p>
<p>Now, checking the implementation like this will USUALLY be equivalent to the behavior - but not always.</p>
<p>But why does this matter to us?</p>
<h1 id="our-scenario">Our scenario<a hidden class="anchor" aria-hidden="true" href="#our-scenario">#</a></h1>
<p>Let’s look at a possible scenario:<br>
We’ve had this test suite for a while, maybe even years.<br>
We’ve invested a lot in them, and we rely on them.</p>
<p>And today, we’re making a change to optimize the database.<br>
We’re moving the description out of the Book table, and into a separate table.</p>
<p>However, we’re not deleting the old field yet - we’ll do that later after all the data has moved to the new table.
<img alt="Code change scenario" loading="lazy" src="/10_footguns/10_footguns_code_change_scenario.png"></p>
<p>Let&rsquo;s say we’re finished with everything else - and it’s time to update the edit-book endpoint.<br>
We&rsquo;ll check what happens if we created a bug, and if we did everything correctly.</p>
<h2 id="what-if-we-created-a-bug">What if we created a bug?<a hidden class="anchor" aria-hidden="true" href="#what-if-we-created-a-bug">#</a></h2>
<p>Now, what if we just FORGOT to update the edit-book endpoint?
Completely forgot.<br>
The edit-book endpoint now changes the wrong field in the database so behavior-wise, it doesn’t do anything.<br>
If this gets to production, then we created a major bug :(</p>
<p><img alt="Edit book bug scenario" loading="lazy" src="/10_footguns/10_footguns_edit_book_bug_scenario.png"></p>
<h3 id="bug--behavior-tests---good">Bug + behavior tests -&gt; good<a hidden class="anchor" aria-hidden="true" href="#bug--behavior-tests---good">#</a></h3>
<p>If we chose behavior tests -
Since the test only uses the external API, it does not care about implementation details.<br>
So if the behavior is wrong, the test will fail, just like it should.</p>
<p>The regression bug was prevented.<br>
Everything’s ok.</p>
<p><img alt="Edit book bug scenario with behavior tests is good" loading="lazy" src="/10_footguns/10_footguns_edit_book_behavior_test_in_bug_scenario_is_good.png"></p>
<h3 id="bug--implementation-tests---not-good">Bug + implementation tests -&gt; not good<a hidden class="anchor" aria-hidden="true" href="#bug--implementation-tests---not-good">#</a></h3>
<p>But we chose the implementation test - it looks directly at old description field in the DB.<br>
When we run the test, the old description field will change, just like before, so the test will not fail.</p>
<p>The regression bug was not prevented.
And a major bug made it to production.</p>
<p>It’s not ok.
<img alt="Edit book bug scenario with implementation tests is bad" loading="lazy" src="/10_footguns/10_footguns_edit_book_implementation_test_in_bug_scenario_is_bad.png"></p>
<h2 id="what-if-we-did-everything-correctly-and-theres-no-bug">What if we did everything correctly and there&rsquo;s no bug?<a hidden class="anchor" aria-hidden="true" href="#what-if-we-did-everything-correctly-and-theres-no-bug">#</a></h2>
<p>On the other side of this, what if we made the change correctly?<br>
Edit-book now changes the new table instead of the old field.<br>
No bug, everything’s fine.
<img alt="Edit book non-bug scenario" loading="lazy" src="/10_footguns/10_footguns_edit_book_non_bug_scenario.png"></p>
<h3 id="no-bug--behavior-tests---good">No bug + behavior tests -&gt; good<a hidden class="anchor" aria-hidden="true" href="#no-bug--behavior-tests---good">#</a></h3>
<p>If we chose the behavior test -
Everything behaves correctly when you just invoke the external endpoints, so the test will pass.<br>
We don’t need to do anything.</p>
<p><img alt="Edit book non-bug scenario with behavior tests is good" loading="lazy" src="/10_footguns/10_footguns_edit_book_behavior_test_in_non_bug_scenario_is_good.png"></p>
<h3 id="no-bug--implementation-tests---not-good">No bug + implementation tests -&gt; not good<a hidden class="anchor" aria-hidden="true" href="#no-bug--implementation-tests---not-good">#</a></h3>
<p>If we chose the implementation test -
The old field is not updated any more, so
even though the code is correct, this test will fail.</p>
<p>The distinction here is that the failure reason is not that the code is not correct.<br>
The test fails because it has become <strong>technically invalid</strong>.</p>
<p>So, we have extra work - we need to figure out whether the failure is real or technical.<br>
And then we’ll need to update the test.<br>
Also - because we just changed the test, we now have less confidence in it. We need to learn to trust it again.</p>
<p><img alt="Edit book non-bug scenario with implementation tests is bad" loading="lazy" src="/10_footguns/10_footguns_edit_book_implementation_test_in_non_bug_scenario_is_bad.png"></p>
<h1 id="this-is-worse-on-large-code-bases">This is worse on large code bases<a hidden class="anchor" aria-hidden="true" href="#this-is-worse-on-large-code-bases">#</a></h1>
<p>On large code bases, this can become a real pain.<br>
You have to update the tests, even if the code change has no bugs, and sometimes even if the test has nothing to do with the feature you worked on.</p>
<p>You end up wasting hours and you hate the test suite.</p>
<h1 id="summing-up-our-thought-experiment">Summing up our thought experiment<a hidden class="anchor" aria-hidden="true" href="#summing-up-our-thought-experiment">#</a></h1>
<p>We can see that in every case we looked at - the behavior test was much better.<br>
Cohesive, behavior tests are closer to reality.</p>
<p>They are better at protecting us.<br>
They create less redundant work.<br>
And we have higher confidence in them in the long run.</p>
<p><img alt="Cohesive tests vs Incohesive tests comparison" loading="lazy" src="/10_footguns/10_footguns_cohesive_tests_vs_incohesive_tests_comparison.png"></p>
<h1 id="what-about-big-changes">What about big changes?<a hidden class="anchor" aria-hidden="true" href="#what-about-big-changes">#</a></h1>
<p>One more thing worth mentioning: we looked at an example of a small, incremental change.<br>
But sometimes, we need to make BIG changes. SCARY changes.<br>
It happens less often but when it happens it’s a big deal.</p>
<p>Large DB changes are a good example:<br>
In many companies, at some point, the DB doesn’t deal with the scale well.<br>
We get stability issues, and we need to make a big change - maybe even move some of the data to a different type of database.<br>
That’s when tests are MOST important.</p>
<p>And if we went with behavior level tests - everything will be fine.<br>
Those same tests that we’ve been running with for 3 years now - we don’t change them.<br>
When they pass, they give us a very strong indication that the logical behavior remains intact.</p>
<p>But if we went with Implementation level tests - they all become technically invalid and they all fail.<br>
We will need to spend time and effort porting all of them to use the new database.<br>
But FAR more importantly: because we’re changing them - we’re not going to trust them enough.<br>
WE WILL TEST EVERYTHING FROM SCRATCH.</p>
<p>This might make the difference between a project that takes a few weeks, and a company-level event that drags out for months while the product has stability issues.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>I cannot recommend enough:</p>
<p>Test behavior.<br>
A cohesive whole, a complete story.</p>
<hr>

<div style="text-align: center; display: block; width: 100%;">
<a href="/posts/10_footguns/06_testing_too_many_things">&lt;&lt; previous post: Testing Too Many Things</a>
|
<a href="/posts/10_footguns/08_test_doubles_everywhere">next post: Test Doubles Everywhere &gt;&gt;</a>
</div>



  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://shaigeva.com/">Shai Geva</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
